
# Multithreaded Convolution benchmarking

## Содержание
1. [Введение](#введение)
-  [Описание матриц фильтров](#описание-матриц-фильтров)
2. [Основные наблюдения](#основные-наблюдения)
- [Тестирование №1 (1226 × 2001)](#Тестирование-№1-(1226-×-2001))
- [Тестирование №2 (1242 x 1227)](#Тестирование-№2-(1242-x-1227))
- [Тестирование №3 (1242 x 1227 - switched)](#Тестирование-№3-(1242-x-1227---switched))
- [Композиции фильтров](#композиции-фильтров)
- [Влияние значений в матрицах](#влияние-значений-в-матрицах)
3. [Заключение](#заключение)

## Введение

Тестирование проводилось на изображениях размером 1226 × 2001 - [image5.bmp](https://github.com/qrutyy/bmp-conv/blob/main/test-img/image5.bmp) и 1242 x 1227 [image4.bmp](https://github.com/qrutyy/bmp-conv/blob/main/test-img/image4.bmp), количестве потоков = 4 и 15 повторах. Точный билд можно найти в [Makefile](https://github.com/qrutyy/bmp-conv/blob/main/2-con/Makefile) (при сборке не использовались оптимизации компилятора), а бенчмарк реализован в [test.sh](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/test.sh).

В реализованные графики не были включены результаты вычислений с по-пиксельным разбиением изображения. Такой метод приводит к созданию большого количества чанков, что ведёт к значительным накладным расходам на управление потоками. В результате, измеренное время выполнения не отражает реальную эффективность алгоритма, а лишь показывает доминирование затрат на синхронизацию.

### Описание матриц фильтров:

| FILTER NAME | SHORT NAME | SIZE |
| ---| --- | --- |
| Big Gaussian Blur | gg | 15x15 |
| Motion Blur | mb | 9x9 |
| Basic Blur | bb | 5x5 |
| Gaussian Blur | gb | 5x5 |
| Emboss | em | 5x5 |
| None | co | 3x3 |
| Sharpen | sh | 3x3 |

## Основные наблюдения

### Тестирование №1 (1226 × 2001)

В целом, размер матрицы фильтра напрямую влияет на время обработки изображения. Чем больше матрица, тем выше вычислительная сложность свёртки и тем больше данных необходимо обработать. 

***fyi**: количество чанков округлено, сомнительные утверждения отмечены * и подвергаются доп. разбору.*

При сравнении различных разбиений изображения выявлены следующие тенденции:

- В методе **by_row** при больших размерах блоков (после 32) наблюдается увеличение времени выполнения, по сравнению с **by_column**.  Во всех случаях, при использовании метода **by_row** оптимальным размером блока является 32. Из этого можно сделать вывод, что 62 чанка размерами по 32x1226 эффективнее, чем 32 чанка по 64x1226 и более. Это показывает, что с размерами блока > 32 затраты на вычисление превосходят оверхед на синхронизацию потоков (тк количество вычисляемых чанков снижается) и становятся доминирующим фактором. *Кроме того, чанки слишком большие, они хуже помещаются в кеш процессора, что увеличивает количество обращений к оперативной памяти и снижает производительность.

- В методе **by_column**, подобного поведения (как в **by_row**) не замечено. При размере блока в 32 (со всеми другими блоками все то же, этот взят для примера), вертикальное разбиение обладает лучшей производительностью чем горизонтальное. То есть 38 чанков с размером 32x2001 вычисляется быстрее чем 62 чанка размерами по 32x1226. Это может быть показателем того, что на производительность влияет не только количество чанков, но и их форма и способ доступа к данным в памяти. 

- *Не исключено, что в любых методах разделения вычислений, при переходе от одной строки к следующей, может происходить кэш-промах, особенно если данные не укладываются в L1/L2 кеш.

- Вычисление с помощью метода **by_grid** показывает результаты схожие с **by_row**. При размере блока < 64 время вычисления является примерно одинаковым, без заметных изменений. Однако после - идет увеличение затрачиваемого времени. Когда блоки маленькие, затраты на синхронизацию примерно равны затратам на вычисления, и всё остаётся сбалансированным, как и в случае с **by_row**.

- Матрицы фильтров с большими размерами имеют примерное одно и то же значение по накладным расходам в процентном соотношении. ([gg](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/gg_execution_time_vs_mode.png), [mb](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/1226x2001/mb_execution_time_vs_mode.png))


Графики представлены в [данной директории](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/1226x2001/).
### Тестирование №2 (1242 x 1227)

Для подтверждения наблюдений из **Тестрования №1** было решено провести тестирование на изображении с примерно одинаковыми размерами по x и y.

- Визуально (поведение графиков) результаты вычислений по всем методам одинаковы. Однако общие значения затраченного времени уменьшились почти вдвое, что логично. 
- Детальнее рассмотрев алгоритм применения фильтра можно заметить, что итерация по пикселям изображения выглядит так:
    ```
    for (x = spec->start_column; x < spec->end_column; x++) {
        for (y = spec->start_row; y < spec->end_row; y++) {
    ``` 
    Все дело в устройстве кэша. В C статические двоичные массивы хранятся в формате *ряд1-ряд2-...-рядN*. Кроме того, в одну кэш-линию, обращение к которой максимально быстрое - в нашем случае вмещается лишь 8 элементов ряда (обычно кэш-линия размером 64 байта, а в матрице хранится double). Из-за итерации по y, мы постоянно (при любом методе вычисления) попадаем в другой ряд, элемент которого точно не находится в текущей кэш-линии. Поэтому проведем дополнительный эксперимент поменяв строчки циклов местами.

Графики представлены в [данной директории](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/1242x1227/).

### Тестирование №3 (1242 x 1227 - switched)

- Заметно уменьшение затрачиваемого времени на вычисление с методом **by_column** при размерах блока <= 32. Также видно уравнивание этих значений с **by_row** и **by_grid**.
- Конкретных визуальных изменений в поведении графика не наблюдается. Увеличение времени выполнения при размерах блока > 32 и методе разбиения **by_row** и **by_grid**, по сравнению с **by_column** до сих пор аномально. Возможно все-таки имеет значение повышенное количество кэш-промахов (что странно) или сложности обращения к следующим элементам строки... idk
 
Графики представлены в [данной директории](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/sw-1242x1227/).

### Композиция фильтров

При последовательном применении нескольких фильтров время выполнения не зависит от порядка их наложения. Это подтверждает предположение, что обработка каждого фильтра не зависит от предыдущих преображений. Следовательно накладные расходы не накапливаются в зависимости от последовательности.

Из-за того, что на графике [графике](https://github.com/qrutyy/bmp-conv/blob/main/2-con/tests/plots/filter_pairs_execution_time.png) значения выглядят искусственно равными - снизу представлены более детальные данные:

| ID | COMPOSITION | AVG TIME |
| ---| --- | ---|
| 0 | gb-sh | 0.264358 |
| 1 | sh-gb | 0.264400 |
| 2 | gg-sh | 1.540230 |
| 3 | sh-gg | 1.540138 |
| 4 | mb-sh | 0.616942 |
| 5 | sh-mb | 0.616794 |

### Влияние значений в матрицах

Зависимость времени выполнения от значений в матрицах при одинаковых размерах остаётся предметом возможных дальнейших исследований. Предположительно, могут вступать в силу различные оптимизации компилятора, такие как векторизация вычислений или специфические преобразования кода, которые влияют на производительность алгоритма.

## Заключение

Проведённый анализ показывает, что:
- Пиксельное разбиение неэффективно из-за высоких накладных расходов на управление потоками.
- Размер фильтра оказывает ключевое влияние на производительность.
- Выбор оптимального способа разделения изображения на единицы обработки зависит от размера и соотношения сторон.
- Последовательность наложения фильтров не влияет на производительность.
- Необходимо подробнее изучить устройство кэша. 

